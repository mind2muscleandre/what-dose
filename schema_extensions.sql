-- ==========================================
-- WHATDOSE SCHEMA EXTENSIONS
-- ==========================================
-- This file extends complete_schema.sql with additional features
-- from the technical implementation plan.
-- ==========================================
-- Run complete_schema.sql first, then this file.
-- ==========================================

-- ==========================================
-- PHASE 1: HIERARCHICAL SUPPLEMENT SEARCH
-- ==========================================

-- 1.1: Modify supplements table for parent-child relationships
ALTER TABLE supplements 
  ADD COLUMN IF NOT EXISTS parent_id BIGINT REFERENCES supplements(id) ON DELETE CASCADE,
  ADD COLUMN IF NOT EXISTS is_parent BOOLEAN DEFAULT FALSE;

CREATE INDEX IF NOT EXISTS idx_supplements_parent ON supplements(parent_id);
CREATE INDEX IF NOT EXISTS idx_supplements_is_parent ON supplements(is_parent) WHERE is_parent = TRUE;

-- 1.2: Advanced search RPC function for hierarchical search
CREATE OR REPLACE FUNCTION search_supplements(search_term TEXT)
RETURNS TABLE (
  parent_id BIGINT,
  parent_name_en TEXT,
  parent_name_sv TEXT,
  parent_description TEXT,
  parent_research_status research_status_type,
  variants JSONB
) AS $$
BEGIN
  RETURN QUERY
  WITH matched_parents AS (
    -- Find parents where name matches OR has a variant that matches
    SELECT DISTINCT 
      COALESCE(s.parent_id, s.id) as p_id
    FROM supplements s
    WHERE 
      -- Parent name matches (case-insensitive, partial match)
      (s.parent_id IS NULL AND (
        s.name_en ILIKE '%' || search_term || '%'
        OR s.name_sv ILIKE '%' || search_term || '%'
      ))
      -- OR variant name matches
      OR (s.parent_id IS NOT NULL AND (
        s.name_en ILIKE '%' || search_term || '%'
        OR s.name_sv ILIKE '%' || search_term || '%'
      ))
  )
  SELECT 
    s.id as parent_id,
    s.name_en as parent_name_en,
    s.name_sv as parent_name_sv,
    COALESCE(s.description, s.dosing_notes) as parent_description,
    s.research_status as parent_research_status,
    -- Aggregate variants as JSONB array
    COALESCE(
      jsonb_agg(
        jsonb_build_object(
          'id', v.id,
          'name_en', v.name_en,
          'name_sv', v.name_sv,
          'default_dosage_val', v.dosing_base_val,
          'max_dosage_val', v.dosing_max_val,
          'unit', v.unit,
          'dosing_notes', v.dosing_notes,
          'bioavailability_notes', v.bioavailability_notes,
          'interaction_risk_text', v.interaction_risk_text,
          'interaction_risk_level', v.interaction_risk_level,
          'research_status', v.research_status,
          'category_ids', v.category_ids
        ) ORDER BY v.name_en
      ) FILTER (WHERE v.id IS NOT NULL),
      '[]'::jsonb
    ) as variants
  FROM supplements s
  LEFT JOIN supplements v ON v.parent_id = s.id
  WHERE s.id IN (SELECT p_id FROM matched_parents)
    AND s.parent_id IS NULL -- Only return parent supplements
  GROUP BY s.id, s.name_en, s.name_sv, s.dosing_notes, s.research_status
  ORDER BY 
    -- Prioritize exact matches, then partial matches
    CASE 
      WHEN s.name_en ILIKE search_term THEN 1
      WHEN s.name_en ILIKE search_term || '%' THEN 2
      ELSE 3
    END,
    s.name_en;
END;
$$ LANGUAGE plpgsql STABLE;

-- Grant execute permission to authenticated users
GRANT EXECUTE ON FUNCTION search_supplements(TEXT) TO authenticated;

-- 1.3: CSV import staging table for supplements
CREATE TABLE IF NOT EXISTS supplement_import_staging (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  import_batch_id UUID DEFAULT uuid_generate_v4(),
  row_data JSONB NOT NULL,
  parent_supplement_name TEXT,
  is_parent BOOLEAN,
  suggested_parent_id BIGINT,
  processed BOOLEAN DEFAULT FALSE,
  processing_error TEXT,
  created_at TIMESTAMPTZ DEFAULT TIMEZONE('utc', NOW()),
  processed_at TIMESTAMPTZ
);

CREATE INDEX IF NOT EXISTS idx_supplement_import_batch ON supplement_import_staging(import_batch_id);
CREATE INDEX IF NOT EXISTS idx_supplement_import_unprocessed ON supplement_import_staging(processed, created_at)
  WHERE processed = FALSE;

-- RLS for supplement_import_staging
ALTER TABLE supplement_import_staging ENABLE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS "Import staging is service-only" ON supplement_import_staging;
CREATE POLICY "Import staging is service-only" ON supplement_import_staging FOR ALL 
  USING (auth.jwt() ->> 'role' = 'service_role');

-- 1.4: CSV processing function for supplements
CREATE OR REPLACE FUNCTION process_supplement_import_batch(batch_id UUID)
RETURNS TABLE(processed_count INTEGER, error_count INTEGER, parents_created INTEGER, variants_created INTEGER) AS $$
DECLARE
  processed_count INTEGER := 0;
  error_count INTEGER := 0;
  parents_created INTEGER := 0;
  variants_created INTEGER := 0;
  row_rec RECORD;
  parent_supplement_id BIGINT;
BEGIN
  -- First pass: Identify and create parent supplements
  FOR row_rec IN 
    SELECT id, row_data, parent_supplement_name, is_parent
    FROM supplement_import_staging 
    WHERE import_batch_id = batch_id 
      AND processed = FALSE 
      AND is_parent = TRUE
    ORDER BY row_data->>'name_en'
  LOOP
    BEGIN
      -- Insert parent supplement
      INSERT INTO supplements (
        name_sv, name_en, research_status, regulatory_status,
        dosing_base_val, dosing_max_val, unit,
        dosing_notes, bioavailability_notes, interaction_risk_text, 
        interaction_risk_level, is_base_health, category_ids, is_parent
      )
      VALUES (
        row_rec.row_data->>'name_sv',
        row_rec.row_data->>'name_en',
        COALESCE((row_rec.row_data->>'research_status')::research_status_type, 'Blue'::research_status_type),
        'Supplement'::regulatory_type,
        COALESCE((row_rec.row_data->>'dosing_base_val')::NUMERIC, NULL),
        COALESCE((row_rec.row_data->>'dosing_max_val')::NUMERIC, NULL),
        COALESCE((row_rec.row_data->>'unit')::unit_type, NULL),
        row_rec.row_data->>'description',
        row_rec.row_data->>'bioavailability',
        row_rec.row_data->>'interaction_risk',
        COALESCE((row_rec.row_data->>'interaction_risk_level')::risk_level_type, 'Low'::risk_level_type),
        COALESCE((row_rec.row_data->>'is_base_health')::BOOLEAN, FALSE),
        string_to_array(row_rec.row_data->>'category_ids', ';')::INT[],
        TRUE
      )
      ON CONFLICT DO NOTHING
      RETURNING id INTO parent_supplement_id;
      
      IF parent_supplement_id IS NULL THEN
        -- Parent already exists, fetch its ID
        SELECT id INTO parent_supplement_id 
        FROM supplements 
        WHERE name_en = row_rec.row_data->>'name_en' 
          AND parent_id IS NULL
        LIMIT 1;
      ELSE
        parents_created := parents_created + 1;
      END IF;
      
      -- Update staging record with parent_id
      UPDATE supplement_import_staging 
      SET suggested_parent_id = parent_supplement_id,
          processed = TRUE, 
          processed_at = NOW()
      WHERE id = row_rec.id;
      
      processed_count := processed_count + 1;
    EXCEPTION WHEN OTHERS THEN
      UPDATE supplement_import_staging 
      SET processed = TRUE, processing_error = SQLERRM, processed_at = NOW()
      WHERE id = row_rec.id;
      error_count := error_count + 1;
    END;
  END LOOP;
  
  -- Second pass: Link variants to their parents by parent_supplement_name
  UPDATE supplement_import_staging s
  SET suggested_parent_id = p.id
  FROM supplements p
  WHERE s.import_batch_id = batch_id
    AND s.processed = FALSE
    AND s.is_parent = FALSE
    AND s.parent_supplement_name IS NOT NULL
    AND p.name_en = s.parent_supplement_name
    AND p.parent_id IS NULL
    AND p.is_parent = TRUE;
  
  -- Third pass: Create variant supplements with parent_id
  FOR row_rec IN 
    SELECT id, row_data, suggested_parent_id
    FROM supplement_import_staging 
    WHERE import_batch_id = batch_id 
      AND processed = FALSE 
      AND is_parent = FALSE
      AND suggested_parent_id IS NOT NULL
  LOOP
    BEGIN
      -- Insert variant supplement
      INSERT INTO supplements (
        parent_id, name_sv, name_en, research_status, regulatory_status,
        dosing_base_val, dosing_max_val, unit,
        dosing_notes, bioavailability_notes, interaction_risk_text, 
        interaction_risk_level, is_base_health, category_ids, is_parent
      )
      VALUES (
        row_rec.suggested_parent_id,
        row_rec.row_data->>'name_sv',
        row_rec.row_data->>'name_en',
        COALESCE((row_rec.row_data->>'research_status')::research_status_type, 'Blue'::research_status_type),
        'Supplement'::regulatory_type,
        COALESCE((row_rec.row_data->>'dosing_base_val')::NUMERIC, NULL),
        COALESCE((row_rec.row_data->>'dosing_max_val')::NUMERIC, NULL),
        COALESCE((row_rec.row_data->>'unit')::unit_type, NULL),
        row_rec.row_data->>'description',
        row_rec.row_data->>'bioavailability',
        row_rec.row_data->>'interaction_risk',
        COALESCE((row_rec.row_data->>'interaction_risk_level')::risk_level_type, 'Low'::risk_level_type),
        COALESCE((row_rec.row_data->>'is_base_health')::BOOLEAN, FALSE),
        string_to_array(row_rec.row_data->>'category_ids', ';')::INT[],
        FALSE
      );
      
      variants_created := variants_created + 1;
      
      UPDATE supplement_import_staging 
      SET processed = TRUE, processed_at = NOW()
      WHERE id = row_rec.id;
      
      processed_count := processed_count + 1;
    EXCEPTION WHEN OTHERS THEN
      UPDATE supplement_import_staging 
      SET processed = TRUE, processing_error = SQLERRM, processed_at = NOW()
      WHERE id = row_rec.id;
      error_count := error_count + 1;
    END;
  END LOOP;
  
  RETURN QUERY SELECT processed_count, error_count, parents_created, variants_created;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- ==========================================
-- PHASE 2: GAMIFICATION FIELDS IN PROFILES
-- ==========================================

-- 2.1: Add gamification columns to profiles
ALTER TABLE profiles 
  ADD COLUMN IF NOT EXISTS username TEXT,
  ADD COLUMN IF NOT EXISTS xp_total BIGINT DEFAULT 0,
  ADD COLUMN IF NOT EXISTS current_streak INTEGER DEFAULT 0,
  ADD COLUMN IF NOT EXISTS last_active_at TIMESTAMPTZ,
  ADD COLUMN IF NOT EXISTS subscription_tier TEXT DEFAULT 'free' CHECK (subscription_tier IN ('free', 'pro', 'creator'));

-- Add unique constraint on username (deferrable to handle concurrent inserts)
CREATE UNIQUE INDEX IF NOT EXISTS idx_profiles_username ON profiles(username) WHERE username IS NOT NULL;
CREATE INDEX IF NOT EXISTS idx_profiles_xp_total ON profiles(xp_total DESC);

-- ==========================================
-- PHASE 3: SAFETY ENGINE (SUBSTANCES & INTERACTIONS)
-- ==========================================

-- 3.1: Substances table (nodes in the graph)
CREATE TABLE IF NOT EXISTS substances (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  name TEXT NOT NULL,
  name_aliases TEXT[],
  substance_type TEXT NOT NULL CHECK (substance_type IN ('medicine', 'supplement', 'herb', 'food', 'enzyme')),
  description TEXT,
  created_at TIMESTAMPTZ DEFAULT TIMEZONE('utc', NOW()),
  updated_at TIMESTAMPTZ DEFAULT TIMEZONE('utc', NOW())
);

CREATE INDEX IF NOT EXISTS idx_substances_name ON substances(name);
CREATE INDEX IF NOT EXISTS idx_substances_type ON substances(substance_type);

-- 3.2: Interactions table (edges in the graph)
CREATE TABLE IF NOT EXISTS interactions (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  substance_a_id BIGINT REFERENCES substances(id) ON DELETE CASCADE NOT NULL,
  substance_b_id BIGINT REFERENCES substances(id) ON DELETE CASCADE NOT NULL,
  severity INTEGER NOT NULL CHECK (severity BETWEEN 1 AND 5),
  mechanism TEXT,
  description TEXT,
  evidence_level TEXT CHECK (evidence_level IN ('high', 'medium', 'low')),
  source TEXT,
  source_ref TEXT,
  created_at TIMESTAMPTZ DEFAULT TIMEZONE('utc', NOW()),
  updated_at TIMESTAMPTZ DEFAULT TIMEZONE('utc', NOW()),
  UNIQUE(substance_a_id, substance_b_id)
);

CREATE INDEX IF NOT EXISTS idx_interactions_substance_a ON interactions(substance_a_id);
CREATE INDEX IF NOT EXISTS idx_interactions_substance_b ON interactions(substance_b_id);
CREATE INDEX IF NOT EXISTS idx_interactions_severity ON interactions(severity DESC);

-- 3.3: Substance-Supplement mapping
CREATE TABLE IF NOT EXISTS supplement_substances (
  supplement_id BIGINT REFERENCES supplements(id) ON DELETE CASCADE NOT NULL,
  substance_id BIGINT REFERENCES substances(id) ON DELETE CASCADE NOT NULL,
  PRIMARY KEY (supplement_id, substance_id)
);

CREATE INDEX IF NOT EXISTS idx_supplement_substances_supplement ON supplement_substances(supplement_id);
CREATE INDEX IF NOT EXISTS idx_supplement_substances_substance ON supplement_substances(substance_id);

-- RLS policies for substances and interactions
ALTER TABLE substances ENABLE ROW LEVEL SECURITY;
ALTER TABLE interactions ENABLE ROW LEVEL SECURITY;
ALTER TABLE supplement_substances ENABLE ROW LEVEL SECURITY;

DROP POLICY IF EXISTS "Substances are public" ON substances;
CREATE POLICY "Substances are public" ON substances FOR SELECT USING (true);
DROP POLICY IF EXISTS "Interactions are public" ON interactions;
CREATE POLICY "Interactions are public" ON interactions FOR SELECT USING (true);
DROP POLICY IF EXISTS "Supplement substances are public" ON supplement_substances;
CREATE POLICY "Supplement substances are public" ON supplement_substances FOR SELECT USING (true);

-- ==========================================
-- PHASE 4: HEALTH METRICS TABLE (TIME-SERIES)
-- ==========================================

-- 4.1: Health metrics table with partitioning
-- Note: Primary keys on partitioned tables must include the partition key (recorded_at)
-- If you get an error about existing table with wrong PK, run: DROP TABLE IF EXISTS health_metrics CASCADE; first
CREATE TABLE IF NOT EXISTS health_metrics (
  id UUID DEFAULT uuid_generate_v4(),
  user_id UUID REFERENCES profiles(id) ON DELETE CASCADE NOT NULL,
  type TEXT NOT NULL,
  value NUMERIC NOT NULL,
  unit TEXT,
  source TEXT NOT NULL,
  recorded_at TIMESTAMPTZ NOT NULL,
  metadata JSONB,
  created_at TIMESTAMPTZ DEFAULT TIMEZONE('utc', NOW()),
  PRIMARY KEY (recorded_at, id)
) PARTITION BY RANGE (recorded_at);

-- Create initial partitions for current and next few months
-- Note: Partition names need to be dynamic in production, using pg_partman extension recommended
DO $$
DECLARE
  current_month TIMESTAMPTZ := date_trunc('month', CURRENT_DATE);
  next_month TIMESTAMPTZ := current_month + interval '1 month';
  next_next_month TIMESTAMPTZ := next_month + interval '1 month';
  partition_name TEXT;
BEGIN
  -- Create partition for current month
  partition_name := 'health_metrics_' || to_char(current_month, 'YYYY_MM');
  EXECUTE format('CREATE TABLE IF NOT EXISTS %I PARTITION OF health_metrics FOR VALUES FROM (%L) TO (%L)',
    partition_name, current_month, next_month);
  
  -- Create partition for next month
  partition_name := 'health_metrics_' || to_char(next_month, 'YYYY_MM');
  EXECUTE format('CREATE TABLE IF NOT EXISTS %I PARTITION OF health_metrics FOR VALUES FROM (%L) TO (%L)',
    partition_name, next_month, next_next_month);
END $$;

CREATE INDEX IF NOT EXISTS idx_health_metrics_id ON health_metrics(id);
CREATE INDEX IF NOT EXISTS idx_health_metrics_user_type ON health_metrics(user_id, type, recorded_at DESC);
CREATE INDEX IF NOT EXISTS idx_health_metrics_recorded_at ON health_metrics(recorded_at DESC);

-- RLS for health_metrics
ALTER TABLE health_metrics ENABLE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS "Users view own health metrics" ON health_metrics;
CREATE POLICY "Users view own health metrics" ON health_metrics FOR SELECT USING (auth.uid() = user_id);
DROP POLICY IF EXISTS "Users insert own health metrics" ON health_metrics;
CREATE POLICY "Users insert own health metrics" ON health_metrics FOR INSERT WITH CHECK (auth.uid() = user_id);
DROP POLICY IF EXISTS "Users update own health metrics" ON health_metrics;
CREATE POLICY "Users update own health metrics" ON health_metrics FOR UPDATE USING (auth.uid() = user_id);
DROP POLICY IF EXISTS "Users delete own health metrics" ON health_metrics;
CREATE POLICY "Users delete own health metrics" ON health_metrics FOR DELETE USING (auth.uid() = user_id);

-- ==========================================
-- PHASE 5: PROTOCOLS SYSTEM (GIT-LIKE FORKING)
-- ==========================================

-- 5.1: Protocols table
CREATE TABLE IF NOT EXISTS protocols (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  creator_id UUID REFERENCES profiles(id) ON DELETE CASCADE NOT NULL,
  forked_from_id BIGINT REFERENCES protocols(id) ON DELETE SET NULL,
  title TEXT NOT NULL,
  description TEXT,
  protocol_data JSONB NOT NULL,
  version INTEGER DEFAULT 1,
  is_public BOOLEAN DEFAULT FALSE,
  fork_count INTEGER DEFAULT 0,
  like_count INTEGER DEFAULT 0,
  created_at TIMESTAMPTZ DEFAULT TIMEZONE('utc', NOW()),
  updated_at TIMESTAMPTZ DEFAULT TIMEZONE('utc', NOW())
);

CREATE INDEX IF NOT EXISTS idx_protocols_creator ON protocols(creator_id);
CREATE INDEX IF NOT EXISTS idx_protocols_forked_from ON protocols(forked_from_id);
CREATE INDEX IF NOT EXISTS idx_protocols_public ON protocols(is_public, created_at DESC);
CREATE INDEX IF NOT EXISTS idx_protocols_like_count ON protocols(like_count DESC);

-- 5.2: Protocol access table
CREATE TABLE IF NOT EXISTS protocol_access (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  protocol_id BIGINT REFERENCES protocols(id) ON DELETE CASCADE NOT NULL,
  user_id UUID REFERENCES profiles(id) ON DELETE CASCADE NOT NULL,
  access_type TEXT DEFAULT 'read' CHECK (access_type IN ('read', 'write')),
  granted_by UUID REFERENCES profiles(id),
  created_at TIMESTAMPTZ DEFAULT TIMEZONE('utc', NOW()),
  UNIQUE(protocol_id, user_id)
);

CREATE INDEX IF NOT EXISTS idx_protocol_access_user ON protocol_access(user_id);
CREATE INDEX IF NOT EXISTS idx_protocol_access_protocol ON protocol_access(protocol_id);

-- 5.3: Protocol likes table
CREATE TABLE IF NOT EXISTS protocol_likes (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  protocol_id BIGINT REFERENCES protocols(id) ON DELETE CASCADE NOT NULL,
  user_id UUID REFERENCES profiles(id) ON DELETE CASCADE NOT NULL,
  created_at TIMESTAMPTZ DEFAULT TIMEZONE('utc', NOW()),
  UNIQUE(protocol_id, user_id)
);

CREATE INDEX IF NOT EXISTS idx_protocol_likes_protocol ON protocol_likes(protocol_id);
CREATE INDEX IF NOT EXISTS idx_protocol_likes_user ON protocol_likes(user_id);

-- RLS policies for protocols
ALTER TABLE protocols ENABLE ROW LEVEL SECURITY;
ALTER TABLE protocol_access ENABLE ROW LEVEL SECURITY;
ALTER TABLE protocol_likes ENABLE ROW LEVEL SECURITY;

DROP POLICY IF EXISTS "View protocols" ON protocols;
CREATE POLICY "View protocols" ON protocols FOR SELECT
  USING (
    is_public = true 
    OR auth.uid() = creator_id 
    OR EXISTS (
      SELECT 1 FROM protocol_access pa
      WHERE pa.protocol_id = protocols.id AND pa.user_id = auth.uid()
    )
  );

DROP POLICY IF EXISTS "Users create own protocols" ON protocols;
CREATE POLICY "Users create own protocols" ON protocols FOR INSERT WITH CHECK (auth.uid() = creator_id);
DROP POLICY IF EXISTS "Users update own protocols" ON protocols;
CREATE POLICY "Users update own protocols" ON protocols FOR UPDATE USING (auth.uid() = creator_id);
DROP POLICY IF EXISTS "Users delete own protocols" ON protocols;
CREATE POLICY "Users delete own protocols" ON protocols FOR DELETE USING (auth.uid() = creator_id);

DROP POLICY IF EXISTS "Users manage own protocol access" ON protocol_access;
CREATE POLICY "Users manage own protocol access" ON protocol_access FOR ALL
  USING (auth.uid() = user_id OR EXISTS (
    SELECT 1 FROM protocols WHERE protocols.id = protocol_access.protocol_id AND protocols.creator_id = auth.uid()
  ));

DROP POLICY IF EXISTS "Protocol likes are public" ON protocol_likes;
CREATE POLICY "Protocol likes are public" ON protocol_likes FOR SELECT USING (true);
DROP POLICY IF EXISTS "Users manage own likes" ON protocol_likes;
CREATE POLICY "Users manage own likes" ON protocol_likes FOR ALL USING (auth.uid() = user_id);

-- 5.4: Triggers for protocol fork_count and like_count
CREATE OR REPLACE FUNCTION update_protocol_fork_count()
RETURNS TRIGGER AS $$
BEGIN
  IF NEW.forked_from_id IS NOT NULL THEN
    UPDATE protocols SET fork_count = fork_count + 1 WHERE id = NEW.forked_from_id;
  END IF;
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

DROP TRIGGER IF EXISTS protocol_fork_count_trigger ON protocols;
CREATE TRIGGER protocol_fork_count_trigger
  AFTER INSERT ON protocols
  FOR EACH ROW EXECUTE FUNCTION update_protocol_fork_count();

CREATE OR REPLACE FUNCTION update_protocol_like_count()
RETURNS TRIGGER AS $$
BEGIN
  IF TG_OP = 'INSERT' THEN
    UPDATE protocols SET like_count = like_count + 1 WHERE id = NEW.protocol_id;
    RETURN NEW;
  ELSIF TG_OP = 'DELETE' THEN
    UPDATE protocols SET like_count = GREATEST(like_count - 1, 0) WHERE id = OLD.protocol_id;
    RETURN OLD;
  END IF;
  RETURN NULL;
END;
$$ LANGUAGE plpgsql;

DROP TRIGGER IF EXISTS protocol_like_count_trigger ON protocol_likes;
CREATE TRIGGER protocol_like_count_trigger
  AFTER INSERT OR DELETE ON protocol_likes
  FOR EACH ROW EXECUTE FUNCTION update_protocol_like_count();

-- ==========================================
-- PHASE 6: N-OF-1 EXPERIMENTS TABLE
-- ==========================================

CREATE TABLE IF NOT EXISTS experiments (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  user_id UUID REFERENCES profiles(id) ON DELETE CASCADE NOT NULL,
  protocol_id BIGINT REFERENCES protocols(id) ON DELETE SET NULL,
  title TEXT NOT NULL,
  description TEXT,
  intervention JSONB NOT NULL,
  control JSONB,
  metric TEXT NOT NULL,
  metric_source TEXT,
  design TEXT NOT NULL CHECK (design IN ('AB', 'ABAB', 'RCT', 'Crossover')),
  block_duration_days INTEGER NOT NULL,
  start_date DATE NOT NULL,
  end_date DATE,
  status TEXT DEFAULT 'draft' CHECK (status IN ('draft', 'active', 'completed', 'paused')),
  results JSONB,
  created_at TIMESTAMPTZ DEFAULT TIMEZONE('utc', NOW()),
  updated_at TIMESTAMPTZ DEFAULT TIMEZONE('utc', NOW())
);

CREATE INDEX IF NOT EXISTS idx_experiments_user ON experiments(user_id);
CREATE INDEX IF NOT EXISTS idx_experiments_status ON experiments(status, start_date DESC);
CREATE INDEX IF NOT EXISTS idx_experiments_protocol ON experiments(protocol_id) WHERE protocol_id IS NOT NULL;

-- RLS for experiments
ALTER TABLE experiments ENABLE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS "Users manage own experiments" ON experiments;
CREATE POLICY "Users manage own experiments" ON experiments FOR ALL USING (auth.uid() = user_id);

-- ==========================================
-- PHASE 7: TERRA API INTEGRATION
-- ==========================================

-- 7.1: Terra connections table
CREATE TABLE IF NOT EXISTS terra_connections (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  user_id UUID REFERENCES profiles(id) ON DELETE CASCADE NOT NULL,
  terra_user_id TEXT NOT NULL,
  provider TEXT NOT NULL,
  status TEXT DEFAULT 'connected' CHECK (status IN ('connected', 'disconnected', 'error')),
  last_sync_at TIMESTAMPTZ,
  created_at TIMESTAMPTZ DEFAULT TIMEZONE('utc', NOW()),
  updated_at TIMESTAMPTZ DEFAULT TIMEZONE('utc', NOW()),
  UNIQUE(user_id, provider)
);

CREATE INDEX IF NOT EXISTS idx_terra_connections_user ON terra_connections(user_id);
CREATE INDEX IF NOT EXISTS idx_terra_connections_provider ON terra_connections(provider);

-- 7.2: Terra webhook staging table
CREATE TABLE IF NOT EXISTS terra_webhook_staging (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  payload JSONB NOT NULL,
  terra_signature TEXT,
  processed BOOLEAN DEFAULT FALSE,
  processing_error TEXT,
  created_at TIMESTAMPTZ DEFAULT TIMEZONE('utc', NOW()),
  processed_at TIMESTAMPTZ
);

CREATE INDEX IF NOT EXISTS idx_terra_webhook_unprocessed ON terra_webhook_staging(processed, created_at)
  WHERE processed = FALSE;

-- RLS for Terra tables
ALTER TABLE terra_connections ENABLE ROW LEVEL SECURITY;
ALTER TABLE terra_webhook_staging ENABLE ROW LEVEL SECURITY;

DROP POLICY IF EXISTS "Users manage own Terra connections" ON terra_connections;
CREATE POLICY "Users manage own Terra connections" ON terra_connections FOR ALL USING (auth.uid() = user_id);
DROP POLICY IF EXISTS "Webhook staging is service-only" ON terra_webhook_staging;
CREATE POLICY "Webhook staging is service-only" ON terra_webhook_staging FOR ALL 
  USING (auth.jwt() ->> 'role' = 'service_role');

-- ==========================================
-- PHASE 8: CSV IMPORT SUPPORT (SUBSTANCES)
-- ==========================================

CREATE TABLE IF NOT EXISTS substance_import_staging (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  import_batch_id UUID DEFAULT uuid_generate_v4(),
  row_data JSONB NOT NULL,
  processed BOOLEAN DEFAULT FALSE,
  processing_error TEXT,
  created_at TIMESTAMPTZ DEFAULT TIMEZONE('utc', NOW()),
  processed_at TIMESTAMPTZ
);

CREATE INDEX IF NOT EXISTS idx_substance_import_batch ON substance_import_staging(import_batch_id);
CREATE INDEX IF NOT EXISTS idx_substance_import_unprocessed ON substance_import_staging(processed, created_at)
  WHERE processed = FALSE;

-- RLS for substance_import_staging
ALTER TABLE substance_import_staging ENABLE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS "Import staging is service-only" ON substance_import_staging;
CREATE POLICY "Import staging is service-only" ON substance_import_staging FOR ALL 
  USING (auth.jwt() ->> 'role' = 'service_role');

-- Processing function for substances
CREATE OR REPLACE FUNCTION process_substance_import_batch(batch_id UUID)
RETURNS TABLE(processed_count INTEGER, error_count INTEGER) AS $$
DECLARE
  processed_count INTEGER := 0;
  error_count INTEGER := 0;
  row_rec RECORD;
BEGIN
  FOR row_rec IN 
    SELECT id, row_data FROM substance_import_staging 
    WHERE import_batch_id = batch_id AND processed = FALSE
  LOOP
    BEGIN
      -- Insert substance and interactions from row_data
      -- (Detailed logic depends on CSV structure - placeholder implementation)
      -- TODO: Implement based on actual CSV structure
      
      UPDATE substance_import_staging 
      SET processed = TRUE, processed_at = NOW()
      WHERE id = row_rec.id;
      
      processed_count := processed_count + 1;
    EXCEPTION WHEN OTHERS THEN
      UPDATE substance_import_staging 
      SET processed = TRUE, processing_error = SQLERRM, processed_at = NOW()
      WHERE id = row_rec.id;
      
      error_count := error_count + 1;
    END;
  END LOOP;
  
  RETURN QUERY SELECT processed_count, error_count;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- ==========================================
-- PHASE 9: XP/GAMIFICATION TRIGGERS
-- ==========================================

-- 9.1: Trigger to update XP on activity completion
CREATE OR REPLACE FUNCTION update_user_xp()
RETURNS TRIGGER AS $$
DECLARE
  xp_gained BIGINT;
BEGIN
  -- Award XP based on activity type
  IF TG_TABLE_NAME = 'daily_task_completions' AND NEW.is_completed = TRUE THEN
    xp_gained := 10;
  ELSIF TG_TABLE_NAME = 'daily_checkins' THEN
    xp_gained := 5;
  ELSIF TG_TABLE_NAME = 'daily_logs' AND NEW.status = 'taken' THEN
    xp_gained := 2;
  ELSE
    RETURN NEW;
  END IF;
  
  UPDATE profiles 
  SET xp_total = xp_total + xp_gained,
      last_active_at = NOW()
  WHERE id = NEW.user_id;
  
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Create triggers for XP updates
DROP TRIGGER IF EXISTS xp_on_task_completion ON daily_task_completions;
DROP TRIGGER IF EXISTS xp_on_task_completion ON daily_task_completions;
CREATE TRIGGER xp_on_task_completion 
  AFTER INSERT OR UPDATE ON daily_task_completions
  FOR EACH ROW 
  WHEN (NEW.is_completed = TRUE)
  EXECUTE FUNCTION update_user_xp();

DROP TRIGGER IF EXISTS xp_on_checkin ON daily_checkins;
DROP TRIGGER IF EXISTS xp_on_checkin ON daily_checkins;
CREATE TRIGGER xp_on_checkin 
  AFTER INSERT ON daily_checkins
  FOR EACH ROW 
  EXECUTE FUNCTION update_user_xp();

DROP TRIGGER IF EXISTS xp_on_daily_log ON daily_logs;
DROP TRIGGER IF EXISTS xp_on_daily_log ON daily_logs;
CREATE TRIGGER xp_on_daily_log 
  AFTER INSERT ON daily_logs
  FOR EACH ROW 
  WHEN (NEW.status = 'taken')
  EXECUTE FUNCTION update_user_xp();

-- 9.2: Trigger to update streak
CREATE OR REPLACE FUNCTION update_user_streak()
RETURNS TRIGGER AS $$
DECLARE
  last_active DATE;
  current_date_val DATE := CURRENT_DATE;
BEGIN
  SELECT last_active_at::DATE INTO last_active FROM profiles WHERE id = NEW.user_id;
  
  IF last_active IS NULL OR last_active < current_date_val - INTERVAL '1 day' THEN
    -- Reset streak
    UPDATE profiles SET current_streak = 1, last_active_at = NOW() WHERE id = NEW.user_id;
  ELSIF last_active = current_date_val - INTERVAL '1 day' THEN
    -- Continue streak
    UPDATE profiles SET current_streak = current_streak + 1, last_active_at = NOW() WHERE id = NEW.user_id;
  ELSIF last_active = current_date_val THEN
    -- Same day, don't increment but update timestamp
    UPDATE profiles SET last_active_at = NOW() WHERE id = NEW.user_id;
  END IF;
  
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Create triggers for streak updates (same events as XP)
DROP TRIGGER IF EXISTS streak_on_task_completion ON daily_task_completions;
DROP TRIGGER IF EXISTS streak_on_task_completion ON daily_task_completions;
CREATE TRIGGER streak_on_task_completion 
  AFTER INSERT OR UPDATE ON daily_task_completions
  FOR EACH ROW 
  WHEN (NEW.is_completed = TRUE)
  EXECUTE FUNCTION update_user_streak();

DROP TRIGGER IF EXISTS streak_on_checkin ON daily_checkins;
DROP TRIGGER IF EXISTS streak_on_checkin ON daily_checkins;
CREATE TRIGGER streak_on_checkin 
  AFTER INSERT ON daily_checkins
  FOR EACH ROW 
  EXECUTE FUNCTION update_user_streak();

DROP TRIGGER IF EXISTS streak_on_daily_log ON daily_logs;
DROP TRIGGER IF EXISTS streak_on_daily_log ON daily_logs;
CREATE TRIGGER streak_on_daily_log 
  AFTER INSERT ON daily_logs
  FOR EACH ROW 
  WHEN (NEW.status = 'taken')
  EXECUTE FUNCTION update_user_streak();

-- ==========================================
-- ADDITIONAL INDEXES FOR PERFORMANCE
-- ==========================================

-- For interaction safety checks (finding interactions for a user's stack)
CREATE INDEX IF NOT EXISTS idx_user_stacks_user_active ON user_stacks(user_id, is_active) WHERE is_active = TRUE;

-- For protocol attribution tree (finding all forks of a protocol)
-- (Recursive queries will benefit from existing index on forked_from_id)

-- Update triggers for updated_at on new tables
DROP TRIGGER IF EXISTS update_substances_updated_at ON substances;
CREATE TRIGGER update_substances_updated_at BEFORE UPDATE ON substances
  FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

DROP TRIGGER IF EXISTS update_interactions_updated_at ON interactions;
CREATE TRIGGER update_interactions_updated_at BEFORE UPDATE ON interactions
  FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

DROP TRIGGER IF EXISTS update_protocols_updated_at ON protocols;
CREATE TRIGGER update_protocols_updated_at BEFORE UPDATE ON protocols
  FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

DROP TRIGGER IF EXISTS update_experiments_updated_at ON experiments;
CREATE TRIGGER update_experiments_updated_at BEFORE UPDATE ON experiments
  FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

DROP TRIGGER IF EXISTS update_terra_connections_updated_at ON terra_connections;
CREATE TRIGGER update_terra_connections_updated_at BEFORE UPDATE ON terra_connections
  FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

-- ==========================================
-- END OF SCHEMA EXTENSIONS
-- ==========================================
